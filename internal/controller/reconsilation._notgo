package controller

import (
	"context"
	"fmt"

	"github.com/go-logr/logr"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/record"
	runtimeClient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	cachev1 "github.com/0x0BSoD/memcached-operator/api/v1"
)

type ReconciliationContext struct {
	Request   *reconcile.Request
	Client    runtimeClient.Client
	Scheme    *runtime.Scheme
	Memcached *cachev1.Memcached
	Recorder  record.EventRecorder
	ReqLogger logr.Logger

	Services     []*corev1.Service
	Endpoints    *corev1.Endpoints
	statefulSets []*appsv1.StatefulSet
	dcPods       []*corev1.Pod
	clusterPods  []*corev1.Pod
}

func CreateReconciliationContext(
	ctx context.Context,
	req *reconcile.Request,
	cli runtimeClient.Client,
	scheme *runtime.Scheme,
	rec record.EventRecorder) (*ReconciliationContext, error) {

	reqLogger := log.FromContext(ctx)
	rc := &ReconciliationContext{}
	rc.Request = req
	rc.Client = cli
	rc.Scheme = scheme
	rc.Recorder = &LoggingEventRecorder{EventRecorder: rec, ReqLogger: reqLogger}
	rc.ReqLogger = reqLogger

	rc.ReqLogger = rc.ReqLogger.
		WithValues("namespace", req.Namespace)

	rc.ReqLogger.Info("handler::CreateReconciliationContext")

	// Try to get memcached instance
	mc := &cachev1.Memcached{}
	err := rc.Client.Get(ctx, req.NamespacedName, mc)
	if err != nil {
		rc.ReqLogger.Error(err, "error in retrieve memcached")
		return nil, err
	}
	rc.Memcached = mc

	rc.ReqLogger = rc.ReqLogger.
		WithValues("memcahedName", mc.Name)

	log.IntoContext(ctx, rc.ReqLogger)

	return rc, nil
}

func (rc *ReconciliationContext) ProcessDeletion() ReconcileResult {
	if rc.Memcached.GetDeletionTimestamp() == nil {
		return Continue()
	}

	return DoneReconsile()
}

func (rc *ReconciliationContext) CalculateReconciliationActions() (reconcile.Result, error) {

	rc.ReqLogger.Info("handler::calculateReconciliationActions")

	result, err := rc.ReconcileAll()

	// Check if the CassandraDatacenter was marked to be deleted
	if result := rc.ProcessDeletion(); result.Completed() {
		return result.Output()
	}

	return result, err
}

func (rc *ReconciliationContext) CheckForInvalidState() ReconcileResult {
	cond, isSet := rc.Memcached.GetCondition(cachev1.MemcachedReady)
	if isSet && cond.Status == corev1.ConditionFalse {
		err := fmt.Errorf("memcached %s is not in a valid state: %s", rc.Memcached.Name, cond.Message)
		return Error(err)
	}

	return Continue()
}

func (rc *ReconciliationContext) ReconcileAll() (reconcile.Result, error) {
	rc.ReqLogger.Info("reconciliationContext::reconcileAllRacks")

	if recResult := rc.CheckForInvalidState(); recResult.Completed() {
		return recResult.Output()
	}

	logger := rc.ReqLogger

	logger.Info("All Deployments should now be reconciled.")

	return DoneReconsile().Output()
}
